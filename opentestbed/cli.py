import base64
import json
import logging
import os
import random
import re
import signal
import string
import sys
import threading

import click
import paho.mqtt.client as mqtt

CLIENT='client'

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
formatter = logging.Formatter(
        '%(asctime)s %(name)-12s %(levelname)-8s %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

otbc = None

class OpenTestbedClient(object):

    def __init__(self, testbed,broker):
        self.testbed = testbed
        self.broker = broker

        self.connected = False
        self.queue = []
        self.token = ''.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(10))

        self.mqttopic_testbed_prefix = '{0}/deviceType/'.format(self.testbed)

        self.mqttclient = mqtt.Client('cli{}'.format(self.token))
        self.mqttclient.on_connect = self._on_mqtt_connect
        self.mqttclient.on_message = self._on_mqtt_message
        self.mqttclient.connect(broker)

        self.token_nr = 0

        # start mqtt client
        self.mqttthread = threading.Thread(
            name='mqtt_loop_thread',
            target=self.mqttclient.loop_forever
        )
        self.mqttthread.start()

        print("here")

    def stop(self):
        self.mqttclient._thread_terminate = True
        self.mqttthread.join(timeout=5)

    def _on_mqtt_connect(self, client, userdata, flags, rc):
        client.subscribe('{0}#'.format(self.mqttopic_testbed_prefix))

        self.connected = True

        for publish_args in self.queue:
            self.mqttclient.publish(**publish_args)

        self.queue = None


    def _on_mqtt_message(self, client, userdata, message):
        try:
            m = re.search('{0}/deviceType/([a-z]+)/deviceId/([\w,\-]+)/resp/([a-z]+)'.format(self.testbed), message.topic)

            if m is None:
                #skipping
                return

            deviceType = m.group(1)
            deviceId = m.group(2)
            cmd = m.group(3)

            body = json.loads(message.payload.decode("utf8"))

            if isinstance(body.get('token'),str) and body['token'].startswith(self.token):
                if bool(body['success']):
                    contents = body['returnVal']
                else:
                    contents = 'EXCEPTION: ' + body['exception']

                print("{} {:>10s}: {}".format(deviceType[0], deviceId, contents))
            else:
                print('token does not match: {} vs {} for message {}'.
                      format(body.get('token'), self.token, message.payload))
        except Exception as e:
            logger.exception("Error while handling message")


    def publish_command(self, deviceType, deviceId, cmd, **kwargs):
        msg_token = "{}{:02d}".format(self.token, self.token_nr)
        self.token_nr += 1

        topic = '{0}{1}/deviceId/{2}/cmd/{3}'.format(self.mqttopic_testbed_prefix, deviceType, deviceId, cmd)
        payload = json.dumps({**kwargs, 'token': msg_token})

        publish_args = {'topic': topic, 'payload': payload}

        if self.connected:


            self.mqttclient.publish(**publish_args)
        else:
            self.queue.append(publish_args)

def stop():
    global otbc

    logger.warning("Stopping...")
    if otbc:
        otbc.stop()

    else:
        logger.warning("No client to stop!")

    sys.exit(0)

def signal_handler(sig, frame):
    stop()

signal.signal(signal.SIGINT, signal_handler)

@click.group()
@click.option("-t", "--testbed", required=True, envvar='OTB_TESTBED', default="opentestbed",
              type=click.Choice(['iotlab', 'opentestbed', 'wilab']))
@click.option('-b', '--broker', required=True, envvar='OTB_BROKER', help="The MQTT broker address")
@click.pass_context
def cli(ctx,testbed,broker):
    global otbc

    otbc = OpenTestbedClient(testbed,broker)

    ctx.obj={}
    ctx.obj[CLIENT] = otbc

@cli.command()
@click.option("--box", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.argument("message")
@click.pass_context
def echo(ctx, box, message):
    client = ctx.obj[CLIENT]
    for b in box:
        client.publish_command('box', b, 'echo',payload=message)

@cli.command()
@click.option("--box", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.pass_context
def status(ctx, box):
    client = ctx.obj[CLIENT]
    for b in box:
        client.publish_command('box', b, 'status')

@cli.command()
@click.option("--box", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.pass_context
def discovermotes(ctx, box):
    client = ctx.obj[CLIENT]
    for b in box:
        client.publish_command('box', b, 'discovermotes')

# @cli.command()
# @click.option("--box", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
# @click.argument('version')
# @click.argument('url')
# @click.pass_context
# def changesoftware(ctx, box, version, url):
#     client = ctx.obj[CLIENT]
#     for b in box:
#         client.publish_command('box', b, 'changesoftware',version=version, url=url)

@cli.command()
@click.option("--box",required=True, help="The boxes to which to send the request. (default: all)")
@click.argument('version')
@click.argument('url')
@click.pass_context
def changesoftware(ctx, box, location):
    client = ctx.obj[CLIENT]
    for b in box:
        client.publish_command('box', b, 'changelocation',location)


@cli.command()
@click.option("--mote", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.argument('description')
@click.argument('url')
@click.pass_context
def program_from_url(ctx, mote, description, url):
    client = ctx.obj[CLIENT]
    for m in mote:
        client.publish_command('mote', m, 'program',description=description, url=url)\

@cli.command()
@click.option("--mote", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.argument('file', type=click.Path(exists=True))
@click.pass_context
def program_from_file(ctx, mote, file):
    client = ctx.obj[CLIENT]

    with open(file, 'rb') as f:
        hex = base64.b64encode(f.read()).decode('utf8')

    for m in mote:
        client.publish_command('mote', m, 'program',description=os.path.basename(file), hex=hex)

@cli.command()
@click.option("--mote", default=['all'], multiple=True, help="The boxes to which to send the request. (default: all)")
@click.argument('serialbytes', type=click.File('rb'))
@click.pass_context
def tomoteserialbytes(ctx, mote, serialbytes):
    bytes=[]
    b = serialbytes.read(1)
    while b:
        bytes.append(int.from_bytes(b, byteorder='big')) #byteorder doesn't matter
        b = serialbytes.read(1)


    client = ctx.obj[CLIENT]
    for m in mote:
        client.publish_command('mote', m, 'tomoteserialbytes',serialbytes=bytes)

if __name__ == '__main__':
    cli()
